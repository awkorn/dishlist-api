generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  uid       String  @id
  email     String  @unique
  username  String? @unique
  firstName String?
  lastName  String?
  bio       String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  ownedDishLists    DishList[]             @relation("DishListOwner")
  collaboratedLists DishListCollaborator[]
  followedDishLists DishListFollower[]
  createdRecipes    Recipe[]               @relation("RecipeCreator")
  addedRecipes      DishListRecipe[]       @relation("UserAddedRecipes")
  pinnedDishLists   UserDishListPin[]

  // User following relationships
  followers UserFollow[] @relation("UserFollowers")
  following UserFollow[] @relation("UserFollowing")

  // Notifications
  sentNotifications     Notification[] @relation("NotificationSender")
  receivedNotifications Notification[] @relation("NotificationReceiver")

  // DishList Invites
  sentInvites     DishListInvite[] @relation("InviteSender")
  receivedInvites DishListInvite[] @relation("InviteReceiver")

  @@map("User")
}

model DishList {
  id          String             @id @default(cuid())
  title       String
  description String?
  visibility  DishListVisibility @default(PUBLIC)
  isDefault   Boolean            @default(false)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  // Owner relation
  ownerId String
  owner   User   @relation("DishListOwner", fields: [ownerId], references: [uid], onDelete: Cascade)

  // Relations
  recipes       DishListRecipe[]
  collaborators DishListCollaborator[]
  followers     DishListFollower[]
  invites       DishListInvite[]
  pins          UserDishListPin[]

  @@map("DishList")
}

model Recipe {
  id               String   @id @default(cuid())
  title            String
  description      String?
  instructions     Json     // Changed from String[] - now stores RecipeItem[]
  ingredients      Json     // Changed from String[] - now stores RecipeItem[]
  prepTime         Int?     // minutes
  cookTime         Int?     // minutes
  servings         Int?
  imageUrl         String?
  nutrition        Json?
  tags             String[] @default([])
  originalRecipeId String?  // For tracking copied recipes
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Creator relation
  creatorId String
  creator   User   @relation("RecipeCreator", fields: [creatorId], references: [uid], onDelete: Cascade)

  // Relations
  dishLists DishListRecipe[]

  // Self-reference for original recipe tracking
  originalRecipe Recipe?  @relation("RecipeCopies", fields: [originalRecipeId], references: [id])
  copies         Recipe[] @relation("RecipeCopies")

  @@map("Recipe")
}

model DishListRecipe {
  id      String   @id @default(cuid())
  addedAt DateTime @default(now())

  // Relations
  dishListId String
  dishList   DishList @relation(fields: [dishListId], references: [id], onDelete: Cascade)

  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  // Who added this recipe to the dish list
  addedById String
  addedBy   User   @relation("UserAddedRecipes", fields: [addedById], references: [uid])

  @@unique([dishListId, recipeId])
  @@map("DishListRecipe")
}

model DishListCollaborator {
  id        String   @id @default(cuid())
  invitedAt DateTime @default(now())

  // Relations
  dishListId String
  dishList   DishList @relation(fields: [dishListId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [uid], onDelete: Cascade)

  @@unique([dishListId, userId])
  @@map("DishListCollaborator")
}

model DishListFollower {
  id         String   @id @default(cuid())
  followedAt DateTime @default(now())

  // Relations
  dishListId String
  dishList   DishList @relation(fields: [dishListId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [uid], onDelete: Cascade)

  @@unique([dishListId, userId])
  @@map("DishListFollower")
}

model UserDishListPin {
  id        String   @id @default(cuid())
  pinnedAt  DateTime @default(now())

  // Relations
  dishListId String
  dishList   DishList @relation(fields: [dishListId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [uid], onDelete: Cascade)

  @@unique([dishListId, userId])
  @@map("UserDishListPin")
}

model DishListInvite {
  id        String    @id @default(cuid())
  token     String    @unique @default(cuid()) // Secure token for invite URLs
  expiresAt DateTime                           // 7 days from creation
  usedAt    DateTime?                          // Timestamp when accepted (null if pending)
  createdAt DateTime  @default(now())

  // Relations
  dishListId String
  dishList   DishList @relation(fields: [dishListId], references: [id], onDelete: Cascade)

  inviterId String
  inviter   User   @relation("InviteSender", fields: [inviterId], references: [uid], onDelete: Cascade)

  // For link invites: inviteeId is null (anyone with link can use)
  // For direct invites: inviteeId is set (only that user can use)
  inviteeId String?
  invitee   User?  @relation("InviteReceiver", fields: [inviteeId], references: [uid], onDelete: Cascade)

  @@index([token])
  @@index([dishListId])
  @@index([inviteeId])
  @@index([expiresAt])
  @@map("DishListInvite")
}

model UserFollow {
  id         String       @id @default(cuid())
  status     FollowStatus @default(PENDING)  
  followedAt DateTime     @default(now())
  acceptedAt DateTime?                       

  // Relations
  followerId String
  follower   User   @relation("UserFollowing", fields: [followerId], references: [uid], onDelete: Cascade)

  followingId String
  following   User   @relation("UserFollowers", fields: [followingId], references: [uid], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followingId, status]) 
  @@map("UserFollow")
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  isRead    Boolean          @default(false)
  data      String? // JSON string for additional data
  createdAt DateTime         @default(now())

  // Relations
  senderId String?
  sender   User?   @relation("NotificationSender", fields: [senderId], references: [uid], onDelete: SetNull)

  receiverId String
  receiver   User   @relation("NotificationReceiver", fields: [receiverId], references: [uid], onDelete: Cascade)

  @@map("Notification")
}

// Enums
enum DishListVisibility {
  PUBLIC
  PRIVATE
}

enum NotificationType {
  DISHLIST_INVITATION
  DISHLIST_SHARED
  RECIPE_SHARED
  RECIPE_ADDED
  DISHLIST_FOLLOWED
  COLLABORATION_ACCEPTED
  COLLABORATION_DECLINED
  USER_FOLLOWED       
  FOLLOW_REQUEST         
  FOLLOW_ACCEPTED        
  SYSTEM_UPDATE
}

enum FollowStatus {
  PENDING
  ACCEPTED
}